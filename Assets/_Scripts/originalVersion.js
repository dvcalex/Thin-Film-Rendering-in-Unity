// https://observablehq.com/@alextintin/thin-film-rendering@1468
import define1 from "./e93997d5089d7165@2303.js";
import define2 from "./10023e7d8ddc32bc@90.js";

function _1(md) {
    return (
        md`# Thin Film Rendering`
    )
}

function _2(md) {
    return (
        md`Thin film data are generated by Alexis Benamira using Transfer Matrix Method presented here:\n
### Application of the Transfer Matrix Method to Anti-reflective Coating Rendering
Proceedings of Computer Graphics International 2020\n
https://link.springer.com/chapter/10.1007/978-3-030-61864-3_8`
    )
}

function _3(md) {
    return (
        md`If you find this code usefull, please provide citation to the paper:\n
@inproceedings{Benamira2020,\n
	title        = {Application of the Transfer Matrix Method to Anti-reflective Coating Rendering},
	author       = {Benamira, Alexis and Pattanaik, Sumanta},
	booktitle    = {Proceedings of the 37th Computer Graphics International},
	series       = {CGI '20},
	year         = {2020},
	location     = {Geneva, Switzerland (Online)},
	numpages     = {10},
	publisher    = {Springer},
	pages        = {12},
	year         = {2020},
	organization = {Springer}
}
`
    )
}

function _4(md) {
    return (
        md`For other applications of the Transfer Matrix Method, you can check http://giga.cps.unizar.es/~iguillen/projects/TOG2020_Pearlescence/`
    )
}

function _renderChoice(radio) {
    return radio({
        title: 'Precomputed or real-time rendering',
        description: '',
        options: [
            {label: "Precomputed", value: "0"},
            {label: "Real Time", value: "1"},
        ],
        value: "1"
    });
}


function _coatingChoice(renderChoice, radio) {
    if (renderChoice == 1) {
        return radio({
            title: 'Choose Coating for precomputed',
            description: '',
            options: [
                {label: "1 Layer", value: "1"},
                {label: "2 Layer", value: "2"},
                {label: "3 Layer", value: "3"},
                {label: "4 Layer", value: "4"},
                {label: "5 Layer", value: "5"},
            ],
            value: "1"
        });
    } else {
        return radio({
            title: 'Choose Coating for precomputed',
            description: '',
            options: [
                {label: "Perfect Mirror", value: "0"},
                {label: "1 Layer", value: "1"},
                {label: "4 Layer", value: "2"},
            ],
            value: "1"
        });

    }
}


function _modelChoice(radio) {
    return radio({
        title: 'Choose Model',
        description: '',
        options: [
            {label: "Sphere", value: "Sphere"},
            {label: "Knot", value: "Knot"},
            {label: "Helmet", value: "Helmet"},
            {label: "BoomBox", value: "BoomBox"},
            {label: "Lucy", value: "Lucy"}
        ],
        value: 'Sphere'
    });
}


function _exposure(slider) {
    return (
        slider({
            min: 1,
            max: 100,
            step: 1,
            value: 10,
            title: "Exposure",
            description: "Exposure up to 100x"
        })
    )
}

function _ior1(coatingChoice, renderChoice, columns, slider) {
    if (coatingChoice > 0 && renderChoice == 1) {
        return columns([
            slider({
                min: 1,
                max: 4,
                step: 0.01,
                value: 1.38,
                title: "Layer1",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 10,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 50,
                max: 650,
                step: 1,
                value: 97,
                description: "thickness of layer in nanometer"
            })
        ])
    } else {
        return columns([
            slider({
                min: 1.38,
                max: 1.38,
                step: 0.01,
                value: 1.38,
                title: "Layer1",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 0,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 95,
                max: 95,
                step: 1,
                value: 97,
                description: "thickness of layer in nanometer"
            })
        ])
    }
}


function _ior2(coatingChoice, renderChoice, columns, slider) {
    if (coatingChoice > 1 && renderChoice == 1) {
        return columns([
            slider({
                min: 1,
                max: 4,
                step: 0.01,
                value: 2.05,
                title: "Layer2",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 4,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 50,
                max: 650,
                step: 1,
                value: 130,
                description: "thickness of layer in nanometer"
            })
        ])
    } else {
        return columns([
            slider({
                min: 2.05,
                max: 2.05,
                step: 0.01,
                value: 2.05,
                title: "Layer2",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 0,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 130,
                max: 130,
                step: 1,
                value: 130,
                description: "thickness of layer in nanometer"
            })
        ])
    }
}


function _ior3(coatingChoice, renderChoice, columns, slider) {
    if (coatingChoice > 2 && renderChoice == 1) {
        return columns([
            slider({
                min: 1,
                max: 4,
                step: 0.01,
                value: 1.8,
                title: "Layer3",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 4,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 50,
                max: 650,
                step: 1,
                value: 84,
                description: "thickness of layer in nanometer"
            })
        ])
    } else {
        return columns([
            slider({
                min: 1.6,
                max: 1.6,
                step: 0.01,
                value: 1.8,
                title: "Layer3",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 0,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 84,
                max: 84,
                step: 1,
                value: 84,
                description: "thickness of layer in nanometer"
            })
        ])
    }
}


function _ior4(coatingChoice, renderChoice, columns, slider) {
    if (coatingChoice > 3 && renderChoice == 1) {
        return columns([
            slider({
                min: 1,
                max: 4,
                step: 0.01,
                value: 1.45,
                title: "Layer4",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 4,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 50,
                max: 650,
                step: 1,
                value: 92,
                description: "thickness of layer in nanometer"
            })
        ])
    } else {
        return columns([
            slider({
                min: 1.45,
                max: 1.45,
                step: 0.01,
                value: 1.45,
                title: "Layer4",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 0,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 92,
                max: 92,
                step: 1,
                value: 92,
                description: "thickness of layer in nanometer"
            })
        ])
    }
}


function _ior5(coatingChoice, renderChoice, columns, slider) {
    if (coatingChoice > 4 && renderChoice == 1) {
        return columns([
            slider({
                min: 1,
                max: 4,
                step: 0.01,
                value: 1.5,
                title: "Layer5",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 4,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 50,
                max: 650,
                step: 1,
                value: 0,
                description: "thickness of layer in nanometer"
            })
        ])
    } else {
        return columns([
            slider({
                min: 1.49,
                max: 1.49,
                step: 0.01,
                value: 1.49,
                title: "Layer5",
                description: "real part of ior"
            }),
            slider({
                min: 0,
                max: 0,
                step: 0.01,
                value: 0,
                description: "complex part of ior"
            }),
            slider({
                min: 0,
                max: 0,
                step: 1,
                value: 0,
                description: "thickness of layer in nanometer"
            })
        ])
    }
}


function* _14(createRenderer, createCamera, THREE, loadTextureCube, createMaterial, loadModel) {
    const renderer = createRenderer();
    const camera = createCamera();
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    const textureCube = loadTextureCube();
    //const textureCube = loadHDRTexureCube();
    const material = createMaterial(textureCube);
    const scene = new THREE.Scene();
    scene.background = textureCube;
    loadModel(material, scene);

    controls.addEventListener("change", () => render());
    //render();
    //return renderer.domElement;

    while (true) {
        renderer.render(scene, camera);
        yield renderer.domElement;
    }

    function render() {
        /*
        let timer = - 0.0002 * Date.now();
    
        camera.position.x += ( mouseX - camera.position.x ) * .05;
        camera.position.y += ( - mouseY - camera.position.y ) * .05;
    
        camera.lookAt( scene.position );
    
        //pointLight.position.x = 1500 * Math.cos( timer );
        //pointLight.position.z = 1500 * Math.sin( timer );
        */
        renderer.render(scene, camera);
    }
}


function _getFragmentShader1layer() {
    return (
        function getFragmentShader1layer() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 viewMatrix; // Supplied by ThreeJS
//uniform vec3 cameraPosition; // Supplied by ThreeJS

uniform samplerCube tEnv;
uniform sampler2D tData;
uniform int tonemapFlag;
uniform float exposure;
uniform vec3 layer1;

in vec3 vNormal;
in vec3 vPosition;
in vec2 vUv;

out vec4 fragColor;

#define saturate(a) clamp( a, 0.0, 1.0 )
#define one_over_pi_by_2 0.63661977236
#define TWO_M_PI 6.283185307
#define number_layer 3
#define wavelengths vec3(580.f, 550.f, 480.f)
#define eps 1e-8

vec2 interface_r (int p, vec2 n_i, vec2 n_f,float th_i, float th_f){
    if (p==0){
      vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
      vec2 num = vec2( n_i.x*th_i - n_f.x*th_f,n_i.y*th_i - n_f.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
    else{
      vec2 den = vec2( n_f.x*th_i + n_i.x*th_f ,n_f.y*th_i + n_i.y*th_f);
      vec2 num = vec2( n_f.x*th_i - n_i.x*th_f,n_f.y*th_i - n_i.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
}


vec2 interface_t(int p, vec2 n_i, vec2 n_f, float th_i, float th_f){
    if (p==0)
    {
        vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
    else{
        vec2 den = vec2( n_f.x*th_i + n_i.x*th_f,n_f.y*th_i + n_i.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
}

vec3 tonemap(vec3 color){
  if (tonemapFlag == 0) return color;
  color *= exposure; 
  return saturate( color );
}

vec2 retreive_r(mat4 M){
  float den = M[0][0]*M[0][0]+M[1][0]*M[1][0];
  float num_real = M[0][2]*M[0][0]+M[1][2]*M[1][0];
  float num_imag = M[1][2]*M[0][0]-M[0][2]*M[1][0];
  return vec2(num_real,num_imag)/den;
}

mat4 complex_time_matrix(vec2 t, mat4 M){
      float den = length(t)*length(t);
      return mat4(
            M[0][0]*t.x+M[0][1]*t.y,M[0][1]*t.x-M[0][0]*t.y,M[0][2]*t.x+M[0][3]*t.y,M[0][3]*t.x-M[0][2]*t.y,
            M[0][1]*t.x-M[0][0]*t.y,M[0][0]*t.x+M[0][1]*t.y,M[0][3]*t.x-M[0][2]*t.y,M[0][2]*t.x+M[0][3]*t.y,
            M[2][0]*t.x+M[2][1]*t.y,M[2][1]*t.x-M[2][0]*t.y,M[2][2]*t.x+M[2][3]*t.y,M[2][3]*t.x-M[2][2]*t.y,
            M[2][1]*t.x-M[2][0]*t.y,M[2][0]*t.x+M[2][1]*t.y,M[2][3]*t.x-M[2][2]*t.y,M[2][2]*t.x+M[2][3]*t.y)/den;
}

mat4 Bs_m(vec2 rs){
    return mat4( 1.f, 0.f, rs.x, rs.y,
                 0.f, 1.f, rs.y, rs.x,
                 rs.x, rs.y, 1.f, 0.f,
                 rs.y, rs.x, 0.f, 1.f);
}

mat4 Bp_m(vec2 rp){
    return mat4( 1.f, 0.f, rp.x,rp.y,
                 0.f, 1.f, rp.y, rp.x,
                 rp.x, rp.y, 1.f, 0.f,
                 rp.y, rp.x, 0.f, 1.f);
}

mat4 A_m(vec2 delta){
    return mat4(exp(delta.y)*cos(delta.x),-exp(delta.y)*sin(delta.x), 0.f,0.f,
                -exp(delta.y)*sin(delta.x),exp(delta.y)*cos(delta.x), 0.f,0.f,
                0.f,0.f, exp(-delta.y)*cos(delta.x),exp(-delta.y)*sin(delta.x), 
                0.f,0.f,exp(-delta.y)*sin(delta.x),exp(-delta.y)*cos(delta.x));
}


void main()	{
  vec3 viewDirection = normalize(vPosition);
  vec3 N = normalize(vNormal);
  float incidentAngle = acos(dot(-viewDirection, N));
  float ct[number_layer],d[number_layer];
  vec2 ior[number_layer],t_listp[number_layer-1],t_lists[number_layer-1],r_listp[number_layer-1], r_lists[number_layer-1],delta[number_layer];

  vec3 R = vec3(0.f);
  vec3 reflectDirection = reflect(viewDirection,N);
  //vec3 reflectDirectionWorld = reflectDirection;
  mat4 Ms[number_layer],Mp[number_layer];
  mat4 A,Bp,Bs;

  Ms[0] = mat4(1.f);
  Mp[0] = mat4(1.f);
  
  ior[0] = vec2(1.f,0.f); //air
  ior[1] = vec2(layer1.x,layer1.y);
  ior[2] = vec2(1.49f,0.f); //polypropylène

  d[0] = 1000000.f;
  d[1] = layer1.z;
  d[2] = 1000000.f;

  ct[0] = dot(-viewDirection, N);

  float ctsqr = (1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[1].x)*(ior[0].x/ior[1].x));

  if (ctsqr<0.f)
      R = vec3(1.f);
  else{
    for(int i=0;i<number_layer-1;++i)
    {
      ct[i+1] = sqrt(1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[i+1].x)*(ior[0].x/ior[i+1].x));
      t_listp[i] = interface_t(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_listp[i] = interface_r(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      t_lists[i] = interface_t(0, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_lists[i] = interface_r(0, ior[i], ior[i+1],ct[i], ct[i+1]);
    }

    for(int wavelength = 0;wavelength<3;++wavelength)
    {
        for(int i=1;i<number_layer-1;++i)
        {
            delta[i] = (TWO_M_PI* ior[i] * ct[i]*d[i] / wavelengths[wavelength]);
        }
        for(int i=1;i<number_layer-1;++i)
        {
          A = A_m(delta[i]);
          Bp = Bp_m(r_listp[i]);
          Bs = Bs_m(r_lists[i]);

          Ms[i] = complex_time_matrix(t_lists[i],Ms[i-1])*A*Bs;
          Mp[i] = complex_time_matrix(t_listp[i],Mp[i-1])*A*Bp;
        }

        Bp = Bp_m(r_listp[0]);
        Bs = Bs_m(r_lists[0]);

        Ms[number_layer-1] = complex_time_matrix(t_lists[0],Bs)*Ms[number_layer-2];
        Mp[number_layer-1] = complex_time_matrix(t_listp[0],Bp)*Mp[number_layer-2];

        vec2 rs = retreive_r(Ms[number_layer-1]);
        vec2 rp = retreive_r(Mp[number_layer-1]);

        R[wavelength] = saturate(0.5f*(length(rs)*length(rs)+length(rp)*length(rp)));
    }
  }

  mat3 cameraCoordinateMatrix = mat3(viewMatrix);
  vec3 reflectDirectionWorld = vec3(
  -dot(cameraCoordinateMatrix[0],reflectDirection),
  dot(cameraCoordinateMatrix[1],reflectDirection),
  dot(cameraCoordinateMatrix[2],reflectDirection)
  );
  
  vec3 vColor = texture(tEnv,reflectDirectionWorld).rgb*R*ct[0]*exposure;
  fragColor = vec4(vColor, 1.f );
}`;
        }
    )
}

function _getFragmentShader2layers() {
    return (
        function getFragmentShader2layers() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 viewMatrix; // Supplied by ThreeJS
//uniform vec3 cameraPosition; // Supplied by ThreeJS

uniform samplerCube tEnv;
uniform int tonemapFlag;
uniform float exposure;
uniform vec3 layer1;
uniform vec3 layer2;

in vec3 vNormal;
in vec3 vPosition;
in vec2 vUv;

out vec4 fragColor;

#define saturate(a) clamp( a, 0.0, 1.0 )
#define one_over_pi_by_2 0.63661977236
#define TWO_M_PI 6.283185307
#define number_layer 4
#define wavelengths vec3(580.f, 550.f, 480.f)
#define eps 1e-8

vec2 interface_r (int p, vec2 n_i, vec2 n_f,float th_i, float th_f){
    if (p==0){
      vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
      vec2 num = vec2( n_i.x*th_i - n_f.x*th_f,n_i.y*th_i - n_f.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
    else{
      vec2 den = vec2( n_f.x*th_i + n_i.x*th_f ,n_f.y*th_i + n_i.y*th_f);
      vec2 num = vec2( n_f.x*th_i - n_i.x*th_f,n_f.y*th_i - n_i.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
}


vec2 interface_t(int p, vec2 n_i, vec2 n_f, float th_i, float th_f){
    if (p==0)
    {
        vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
    else{
        vec2 den = vec2( n_f.x*th_i + n_i.x*th_f,n_f.y*th_i + n_i.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
}

vec3 tonemap(vec3 color){
  if (tonemapFlag == 0) return color;
  color *= exposure; 
  return saturate( color );
}

vec2 retreive_r(mat4 M){
  float den = M[0][0]*M[0][0]+M[1][0]*M[1][0];
  float num_real = M[0][2]*M[0][0]+M[1][2]*M[1][0];
  float num_imag = M[1][2]*M[0][0]-M[0][2]*M[1][0];
  return vec2(num_real,num_imag)/den;
}

mat4 complex_time_matrix(vec2 t, mat4 M){
      float den = length(t)*length(t);
      return mat4(
            M[0][0]*t.x+M[0][1]*t.y,M[0][1]*t.x-M[0][0]*t.y,M[0][2]*t.x+M[0][3]*t.y,M[0][3]*t.x-M[0][2]*t.y,
            M[0][1]*t.x-M[0][0]*t.y,M[0][0]*t.x+M[0][1]*t.y,M[0][3]*t.x-M[0][2]*t.y,M[0][2]*t.x+M[0][3]*t.y,
            M[2][0]*t.x+M[2][1]*t.y,M[2][1]*t.x-M[2][0]*t.y,M[2][2]*t.x+M[2][3]*t.y,M[2][3]*t.x-M[2][2]*t.y,
            M[2][1]*t.x-M[2][0]*t.y,M[2][0]*t.x+M[2][1]*t.y,M[2][3]*t.x-M[2][2]*t.y,M[2][2]*t.x+M[2][3]*t.y)/den;
}

mat4 Bs_m(vec2 rs){
    return mat4( 1.f, 0.f, rs.x, rs.y,
                 0.f, 1.f, rs.y, rs.x,
                 rs.x, rs.y, 1.f, 0.f,
                 rs.y, rs.x, 0.f, 1.f);
}

mat4 Bp_m(vec2 rp){
    return mat4( 1.f, 0.f, rp.x,rp.y,
                 0.f, 1.f, rp.y, rp.x,
                 rp.x, rp.y, 1.f, 0.f,
                 rp.y, rp.x, 0.f, 1.f);
}

mat4 A_m(vec2 delta){
    return mat4(exp(delta.y)*cos(delta.x),-exp(delta.y)*sin(delta.x), 0.f,0.f,
                -exp(delta.y)*sin(delta.x),exp(delta.y)*cos(delta.x), 0.f,0.f,
                0.f,0.f, exp(-delta.y)*cos(delta.x),exp(-delta.y)*sin(delta.x), 
                0.f,0.f,exp(-delta.y)*sin(delta.x),exp(-delta.y)*cos(delta.x));
}


void main()	{
  vec3 viewDirection = normalize(vPosition);
  //vec3 viewDirection = normalize(vPosition-cameraPosition);
  vec3 N = normalize(vNormal);
  float incidentAngle = acos(dot(-viewDirection, N));
  float ct[number_layer],d[number_layer];
  vec2 ior[number_layer],t_listp[number_layer-1],t_lists[number_layer-1],r_listp[number_layer-1], r_lists[number_layer-1],delta[number_layer];

  vec3 R = vec3(0.f);
  vec3 reflectDirection = reflect(viewDirection,N);
  //vec3 reflectDirectionWorld = reflectDirection;
  mat4 Ms[number_layer],Mp[number_layer];
  mat4 A,Bp,Bs;

  Ms[0] = mat4(1.f);
  Mp[0] = mat4(1.f);
  
  ior[0] = vec2(1.f,0.f); //air
  ior[1] = vec2(layer1.x,layer1.y);
  ior[2] = vec2(layer2.x,layer2.y);
  ior[3] = vec2(1.49f,0.f); //polypropylène

  d[0] = 1000000.f;
  d[1] = layer1.z;
  d[2] = layer2.z;
  d[3] = 1000000.f;

  ct[0] = dot(-viewDirection, N);

  float ctsqr = (1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[1].x)*(ior[0].x/ior[1].x));

  if (ctsqr<0.f)
      R = vec3(1.f);
  else{
    for(int i=0;i<number_layer-1;++i)
    {
      ct[i+1] = sqrt(1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[i+1].x)*(ior[0].x/ior[i+1].x));
      t_listp[i] = interface_t(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_listp[i] = interface_r(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      t_lists[i] = interface_t(0, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_lists[i] = interface_r(0, ior[i], ior[i+1],ct[i], ct[i+1]);
    }

    for(int wavelength = 0;wavelength<3;++wavelength)
    {
        for(int i=1;i<number_layer-1;++i)
        {
            delta[i] = (TWO_M_PI* ior[i] * ct[i]*d[i] / wavelengths[wavelength]);
        }
        for(int i=1;i<number_layer-1;++i)
        {
          A = A_m(delta[i]);
          Bp = Bp_m(r_listp[i]);
          Bs = Bs_m(r_lists[i]);

          Ms[i] = complex_time_matrix(t_lists[i],Ms[i-1])*A*Bs;
          Mp[i] = complex_time_matrix(t_listp[i],Mp[i-1])*A*Bp;
        }

        Bp = Bp_m(r_listp[0]);
        Bs = Bs_m(r_lists[0]);

        Ms[number_layer-1] = complex_time_matrix(t_lists[0],Bs)*Ms[number_layer-2];
        Mp[number_layer-1] = complex_time_matrix(t_listp[0],Bp)*Mp[number_layer-2];

        vec2 rs = retreive_r(Ms[number_layer-1]);
        vec2 rp = retreive_r(Mp[number_layer-1]);

        R[wavelength] = saturate(0.5f*(length(rs)*length(rs)+length(rp)*length(rp)));
    }
  }

  mat3 cameraCoordinateMatrix = mat3(viewMatrix);
  vec3 reflectDirectionWorld = vec3(
  -dot(cameraCoordinateMatrix[0],reflectDirection),
  dot(cameraCoordinateMatrix[1],reflectDirection),
  dot(cameraCoordinateMatrix[2],reflectDirection)
  );
  
  vec3 vColor = texture(tEnv,reflectDirectionWorld).rgb*R*ct[0]*exposure;
  fragColor = vec4(vColor, 1.f );
}`;
        }
    )
}

function _getFragmentShader3layers() {
    return (
        function getFragmentShader3layers() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 viewMatrix; // Supplied by ThreeJS
//uniform vec3 cameraPosition; // Supplied by ThreeJS

uniform samplerCube tEnv;
uniform int tonemapFlag;
uniform float exposure;
uniform vec3 layer1;
uniform vec3 layer2;
uniform vec3 layer3;

in vec3 vNormal;
in vec3 vPosition;
in vec2 vUv;

out vec4 fragColor;

#define saturate(a) clamp( a, 0.0, 1.0 )
#define one_over_pi_by_2 0.63661977236
#define TWO_M_PI 6.283185307
#define number_layer 5
#define wavelengths vec3(580.f, 550.f, 480.f)
#define eps 1e-8

vec2 interface_r (int p, vec2 n_i, vec2 n_f,float th_i, float th_f){
    if (p==0){
      vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
      vec2 num = vec2( n_i.x*th_i - n_f.x*th_f,n_i.y*th_i - n_f.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
    else{
      vec2 den = vec2( n_f.x*th_i + n_i.x*th_f ,n_f.y*th_i + n_i.y*th_f);
      vec2 num = vec2( n_f.x*th_i - n_i.x*th_f,n_f.y*th_i - n_i.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
}


vec2 interface_t(int p, vec2 n_i, vec2 n_f, float th_i, float th_f){
    if (p==0)
    {
        vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
    else{
        vec2 den = vec2( n_f.x*th_i + n_i.x*th_f,n_f.y*th_i + n_i.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
}

vec3 tonemap(vec3 color){
  if (tonemapFlag == 0) return color;
  color *= exposure; 
  return saturate( color );
}

vec2 retreive_r(mat4 M){
  float den = M[0][0]*M[0][0]+M[1][0]*M[1][0];
  float num_real = M[0][2]*M[0][0]+M[1][2]*M[1][0];
  float num_imag = M[1][2]*M[0][0]-M[0][2]*M[1][0];
  return vec2(num_real,num_imag)/den;
}

mat4 complex_time_matrix(vec2 t, mat4 M){
      float den = length(t)*length(t);
      return mat4(
            M[0][0]*t.x+M[0][1]*t.y,M[0][1]*t.x-M[0][0]*t.y,M[0][2]*t.x+M[0][3]*t.y,M[0][3]*t.x-M[0][2]*t.y,
            M[0][1]*t.x-M[0][0]*t.y,M[0][0]*t.x+M[0][1]*t.y,M[0][3]*t.x-M[0][2]*t.y,M[0][2]*t.x+M[0][3]*t.y,
            M[2][0]*t.x+M[2][1]*t.y,M[2][1]*t.x-M[2][0]*t.y,M[2][2]*t.x+M[2][3]*t.y,M[2][3]*t.x-M[2][2]*t.y,
            M[2][1]*t.x-M[2][0]*t.y,M[2][0]*t.x+M[2][1]*t.y,M[2][3]*t.x-M[2][2]*t.y,M[2][2]*t.x+M[2][3]*t.y)/den;
}

mat4 Bs_m(vec2 rs){
    return mat4( 1.f, 0.f, rs.x, rs.y,
                 0.f, 1.f, rs.y, rs.x,
                 rs.x, rs.y, 1.f, 0.f,
                 rs.y, rs.x, 0.f, 1.f);
}

mat4 Bp_m(vec2 rp){
    return mat4( 1.f, 0.f, rp.x,rp.y,
                 0.f, 1.f, rp.y, rp.x,
                 rp.x, rp.y, 1.f, 0.f,
                 rp.y, rp.x, 0.f, 1.f);
}

mat4 A_m(vec2 delta){
    return mat4(exp(delta.y)*cos(delta.x),-exp(delta.y)*sin(delta.x), 0.f,0.f,
                -exp(delta.y)*sin(delta.x),exp(delta.y)*cos(delta.x), 0.f,0.f,
                0.f,0.f, exp(-delta.y)*cos(delta.x),exp(-delta.y)*sin(delta.x), 
                0.f,0.f,exp(-delta.y)*sin(delta.x),exp(-delta.y)*cos(delta.x));
}


void main()	{
  vec3 viewDirection = normalize(vPosition);
  vec3 N = normalize(vNormal);
  float incidentAngle = acos(dot(-viewDirection, N));
  float ct[number_layer],d[number_layer];
  vec2 ior[number_layer],t_listp[number_layer-1],t_lists[number_layer-1],r_listp[number_layer-1], r_lists[number_layer-1],delta[number_layer];

  vec3 R = vec3(0.f);
  vec3 reflectDirection = reflect(viewDirection,N);
  //vec3 reflectDirectionWorld = reflectDirection;
  mat4 Ms[number_layer],Mp[number_layer];
  mat4 A,Bp,Bs;

  Ms[0] = mat4(1.f);
  Mp[0] = mat4(1.f);
  
 ior[0] = vec2(1.f,0.f); //air
  ior[1] = vec2(layer1.x,layer1.y);
  ior[2] = vec2(layer2.x,layer2.y);
  ior[3] = vec2(layer3.x,layer3.y);
  ior[4] = vec2(1.49f,0.f); //polypropylène

  d[0] = 1000000.f;
  d[1] = layer1.z;
  d[2] = layer2.z;
  d[3] = layer3.z;
  d[4] = 1000000.f;

  ct[0] = dot(-viewDirection, N);

  float ctsqr = (1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[1].x)*(ior[0].x/ior[1].x));

  if (ctsqr<0.f)
      R = vec3(1.f);
  else{
    for(int i=0;i<number_layer-1;++i)
    {
      ct[i+1] = sqrt(1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[i+1].x)*(ior[0].x/ior[i+1].x));
      t_listp[i] = interface_t(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_listp[i] = interface_r(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      t_lists[i] = interface_t(0, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_lists[i] = interface_r(0, ior[i], ior[i+1],ct[i], ct[i+1]);
    }

    for(int wavelength = 0;wavelength<3;++wavelength)
    {
        for(int i=1;i<number_layer-1;++i)
        {
            delta[i] = (TWO_M_PI* ior[i] * ct[i]*d[i] / wavelengths[wavelength]);
        }
        for(int i=1;i<number_layer-1;++i)
        {
          A = A_m(delta[i]);
          Bp = Bp_m(r_listp[i]);
          Bs = Bs_m(r_lists[i]);

          Ms[i] = complex_time_matrix(t_lists[i],Ms[i-1])*A*Bs;
          Mp[i] = complex_time_matrix(t_listp[i],Mp[i-1])*A*Bp;
        }

        Bp = Bp_m(r_listp[0]);
        Bs = Bs_m(r_lists[0]);

        Ms[number_layer-1] = complex_time_matrix(t_lists[0],Bs)*Ms[number_layer-2];
        Mp[number_layer-1] = complex_time_matrix(t_listp[0],Bp)*Mp[number_layer-2];

        vec2 rs = retreive_r(Ms[number_layer-1]);
        vec2 rp = retreive_r(Mp[number_layer-1]);

        R[wavelength] = saturate(0.5f*(length(rs)*length(rs)+length(rp)*length(rp)));
    }
  }

  mat3 cameraCoordinateMatrix = mat3(viewMatrix);
  vec3 reflectDirectionWorld = vec3(
  -dot(cameraCoordinateMatrix[0],reflectDirection),
  dot(cameraCoordinateMatrix[1],reflectDirection),
  dot(cameraCoordinateMatrix[2],reflectDirection)
  );
  
  vec3 vColor = texture(tEnv,reflectDirectionWorld).rgb*R*ct[0]*exposure;
  fragColor = vec4(vColor, 1.f );
}`;
        }
    )
}

function _getFragmentShader4layers() {
    return (
        function getFragmentShader4layers() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 viewMatrix; // Supplied by ThreeJS
//uniform vec3 cameraPosition; // Supplied by ThreeJS

uniform samplerCube tEnv;
uniform sampler2D tData;
uniform int tonemapFlag;
uniform float exposure;
uniform vec3 layer1;
uniform vec3 layer2;
uniform vec3 layer3;
uniform vec3 layer4;

in vec3 vNormal;
in vec3 vPosition;
in vec2 vUv;

out vec4 fragColor;

#define saturate(a) clamp( a, 0.0, 1.0 )
#define one_over_pi_by_2 0.63661977236
#define TWO_M_PI 6.283185307
#define number_layer 6
#define wavelengths vec3(580.f, 550.f, 480.f)
#define eps 1e-8

vec2 interface_r (int p, vec2 n_i, vec2 n_f,float th_i, float th_f){
    if (p==0){
      vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
      vec2 num = vec2( n_i.x*th_i - n_f.x*th_f,n_i.y*th_i - n_f.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
    else{
      vec2 den = vec2( n_f.x*th_i + n_i.x*th_f ,n_f.y*th_i + n_i.y*th_f);
      vec2 num = vec2( n_f.x*th_i - n_i.x*th_f,n_f.y*th_i - n_i.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
}


vec2 interface_t(int p, vec2 n_i, vec2 n_f, float th_i, float th_f){
    if (p==0)
    {
        vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
    else{
        vec2 den = vec2( n_f.x*th_i + n_i.x*th_f,n_f.y*th_i + n_i.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
}

vec3 tonemap(vec3 color){
  if (tonemapFlag == 0) return color;
  color *= exposure; 
  return saturate( color );
}

vec2 retreive_r(mat4 M){
  float den = M[0][0]*M[0][0]+M[1][0]*M[1][0];
  float num_real = M[0][2]*M[0][0]+M[1][2]*M[1][0];
  float num_imag = M[1][2]*M[0][0]-M[0][2]*M[1][0];
  return vec2(num_real,num_imag)/den;
}

mat4 complex_time_matrix(vec2 t, mat4 M){
      float den = length(t)*length(t);
      return mat4(
            M[0][0]*t.x+M[0][1]*t.y,M[0][1]*t.x-M[0][0]*t.y,M[0][2]*t.x+M[0][3]*t.y,M[0][3]*t.x-M[0][2]*t.y,
            M[0][1]*t.x-M[0][0]*t.y,M[0][0]*t.x+M[0][1]*t.y,M[0][3]*t.x-M[0][2]*t.y,M[0][2]*t.x+M[0][3]*t.y,
            M[2][0]*t.x+M[2][1]*t.y,M[2][1]*t.x-M[2][0]*t.y,M[2][2]*t.x+M[2][3]*t.y,M[2][3]*t.x-M[2][2]*t.y,
            M[2][1]*t.x-M[2][0]*t.y,M[2][0]*t.x+M[2][1]*t.y,M[2][3]*t.x-M[2][2]*t.y,M[2][2]*t.x+M[2][3]*t.y)/den;
}

mat4 Bs_m(vec2 rs){
    return mat4( 1.f, 0.f, rs.x, rs.y,
                 0.f, 1.f, rs.y, rs.x,
                 rs.x, rs.y, 1.f, 0.f,
                 rs.y, rs.x, 0.f, 1.f);
}

mat4 Bp_m(vec2 rp){
    return mat4( 1.f, 0.f, rp.x,rp.y,
                 0.f, 1.f, rp.y, rp.x,
                 rp.x, rp.y, 1.f, 0.f,
                 rp.y, rp.x, 0.f, 1.f);
}

mat4 A_m(vec2 delta){
    return mat4(exp(delta.y)*cos(delta.x),-exp(delta.y)*sin(delta.x), 0.f,0.f,
                -exp(delta.y)*sin(delta.x),exp(delta.y)*cos(delta.x), 0.f,0.f,
                0.f,0.f, exp(-delta.y)*cos(delta.x),exp(-delta.y)*sin(delta.x), 
                0.f,0.f,exp(-delta.y)*sin(delta.x),exp(-delta.y)*cos(delta.x));
}


void main()	{
  vec3 viewDirection = normalize(vPosition);
  vec3 N = normalize(vNormal);
  float incidentAngle = acos(dot(-viewDirection, N));
  float ct[number_layer],d[number_layer];
  vec2 ior[number_layer],t_listp[number_layer-1],t_lists[number_layer-1],r_listp[number_layer-1], r_lists[number_layer-1],delta[number_layer];

  vec3 R = vec3(0.f);
  vec3 reflectDirection = reflect(viewDirection,N);
  //vec3 reflectDirectionWorld = reflectDirection;
  mat4 Ms[number_layer],Mp[number_layer];
  mat4 A,Bp,Bs;

  Ms[0] = mat4(1.f);
  Mp[0] = mat4(1.f);
  
 ior[0] = vec2(1.f,0.f); //air
  ior[1] = vec2(layer1.x,layer1.y);
  ior[2] = vec2(layer2.x,layer2.y);
  ior[3] = vec2(layer3.x,layer3.y);
  ior[4] = vec2(layer4.x,layer4.y);
  ior[5] = vec2(1.49f,0.f); //polypropylène

  d[0] = 1000000.f;
  d[1] = layer1.z;
  d[2] = layer2.z;
  d[3] = layer3.z;
  d[4] = layer4.z;
  d[5] = 1000000.f;

  ct[0] = dot(-viewDirection, N);

  float ctsqr = (1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[1].x)*(ior[0].x/ior[1].x));

  if (ctsqr<0.f)
      R = vec3(1.f);
  else{
    for(int i=0;i<number_layer-1;++i)
    {
      ct[i+1] = sqrt(1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[i+1].x)*(ior[0].x/ior[i+1].x));
      t_listp[i] = interface_t(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_listp[i] = interface_r(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      t_lists[i] = interface_t(0, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_lists[i] = interface_r(0, ior[i], ior[i+1],ct[i], ct[i+1]);
    }

    for(int wavelength = 0;wavelength<3;++wavelength)
    {
        for(int i=1;i<number_layer-1;++i)
        {
            delta[i] = (TWO_M_PI* ior[i] * ct[i]*d[i] / wavelengths[wavelength]);
        }
        for(int i=1;i<number_layer-1;++i)
        {
          A = A_m(delta[i]);
          Bp = Bp_m(r_listp[i]);
          Bs = Bs_m(r_lists[i]);

          Ms[i] = complex_time_matrix(t_lists[i],Ms[i-1])*A*Bs;
          Mp[i] = complex_time_matrix(t_listp[i],Mp[i-1])*A*Bp;
        }

        Bp = Bp_m(r_listp[0]);
        Bs = Bs_m(r_lists[0]);

        Ms[number_layer-1] = complex_time_matrix(t_lists[0],Bs)*Ms[number_layer-2];
        Mp[number_layer-1] = complex_time_matrix(t_listp[0],Bp)*Mp[number_layer-2];

        vec2 rs = retreive_r(Ms[number_layer-1]);
        vec2 rp = retreive_r(Mp[number_layer-1]);

        R[wavelength] = saturate(0.5f*(length(rs)*length(rs)+length(rp)*length(rp)));
    }
  }

  mat3 cameraCoordinateMatrix = mat3(viewMatrix);
  vec3 reflectDirectionWorld = vec3(
  -dot(cameraCoordinateMatrix[0],reflectDirection),
  dot(cameraCoordinateMatrix[1],reflectDirection),
  dot(cameraCoordinateMatrix[2],reflectDirection)
  );
  
  vec3 vColor = texture(tEnv,reflectDirectionWorld).rgb*R*ct[0]*exposure;
  fragColor = vec4(vColor, 1.f );
}`;
        }
    )
}

function _getFragmentShader5layers() {
    return (
        function getFragmentShader5layers() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 viewMatrix; // Supplied by ThreeJS
//uniform vec3 cameraPosition; // Supplied by ThreeJS

uniform samplerCube tEnv;
uniform sampler2D tData;
uniform int tonemapFlag;
uniform float exposure;
uniform vec3 layer1;
uniform vec3 layer2;
uniform vec3 layer3;
uniform vec3 layer4;
uniform vec3 layer5;

in vec3 vNormal;
in vec3 vPosition;
in vec2 vUv;

out vec4 fragColor;

#define saturate(a) clamp( a, 0.0, 1.0 )
#define one_over_pi_by_2 0.63661977236
#define TWO_M_PI 6.283185307
#define number_layer 7
#define wavelengths vec3(580.f, 550.f, 480.f)
#define eps 1e-8

vec2 interface_r (int p, vec2 n_i, vec2 n_f,float th_i, float th_f){
    if (p==0){
      vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
      vec2 num = vec2( n_i.x*th_i - n_f.x*th_f,n_i.y*th_i - n_f.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
    else{
      vec2 den = vec2( n_f.x*th_i + n_i.x*th_f ,n_f.y*th_i + n_i.y*th_f);
      vec2 num = vec2( n_f.x*th_i - n_i.x*th_f,n_f.y*th_i - n_i.y*th_f);
      vec2 numxden = vec2(den.x*num.x+den.y*num.y,num.y*den.x-num.x*den.y);
      return numxden/(length(den)*length(den));
    }
}


vec2 interface_t(int p, vec2 n_i, vec2 n_f, float th_i, float th_f){
    if (p==0)
    {
        vec2 den = vec2( n_i.x*th_i + n_f.x*th_f,n_i.y*th_i + n_f.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
    else{
        vec2 den = vec2( n_f.x*th_i + n_i.x*th_f,n_f.y*th_i + n_i.y*th_f);
        vec2 num = 2.f*th_i*vec2(n_i.x*den.x+n_i.y*den.y,-n_i.x*den.y+n_i.y*den.x);
        return num/(length(den)*length(den));
    }
}

vec3 tonemap(vec3 color){
  if (tonemapFlag == 0) return color;
  color *= exposure; 
  return saturate( color );
}

vec2 retreive_r(mat4 M){
  float den = M[0][0]*M[0][0]+M[1][0]*M[1][0];
  float num_real = M[0][2]*M[0][0]+M[1][2]*M[1][0];
  float num_imag = M[1][2]*M[0][0]-M[0][2]*M[1][0];
  return vec2(num_real,num_imag)/den;
}

mat4 complex_time_matrix(vec2 t, mat4 M){
      float den = length(t)*length(t);
      return mat4(
            M[0][0]*t.x+M[0][1]*t.y,M[0][1]*t.x-M[0][0]*t.y,M[0][2]*t.x+M[0][3]*t.y,M[0][3]*t.x-M[0][2]*t.y,
            M[0][1]*t.x-M[0][0]*t.y,M[0][0]*t.x+M[0][1]*t.y,M[0][3]*t.x-M[0][2]*t.y,M[0][2]*t.x+M[0][3]*t.y,
            M[2][0]*t.x+M[2][1]*t.y,M[2][1]*t.x-M[2][0]*t.y,M[2][2]*t.x+M[2][3]*t.y,M[2][3]*t.x-M[2][2]*t.y,
            M[2][1]*t.x-M[2][0]*t.y,M[2][0]*t.x+M[2][1]*t.y,M[2][3]*t.x-M[2][2]*t.y,M[2][2]*t.x+M[2][3]*t.y)/den;
}

mat4 Bs_m(vec2 rs){
    return mat4( 1.f, 0.f, rs.x, rs.y,
                 0.f, 1.f, rs.y, rs.x,
                 rs.x, rs.y, 1.f, 0.f,
                 rs.y, rs.x, 0.f, 1.f);
}

mat4 Bp_m(vec2 rp){
    return mat4( 1.f, 0.f, rp.x,rp.y,
                 0.f, 1.f, rp.y, rp.x,
                 rp.x, rp.y, 1.f, 0.f,
                 rp.y, rp.x, 0.f, 1.f);
}

mat4 A_m(vec2 delta){
    return mat4(exp(delta.y)*cos(delta.x),-exp(delta.y)*sin(delta.x), 0.f,0.f,
                -exp(delta.y)*sin(delta.x),exp(delta.y)*cos(delta.x), 0.f,0.f,
                0.f,0.f, exp(-delta.y)*cos(delta.x),exp(-delta.y)*sin(delta.x), 
                0.f,0.f,exp(-delta.y)*sin(delta.x),exp(-delta.y)*cos(delta.x));
}


void main()	{
  vec3 viewDirection = normalize(vPosition);
  vec3 N = normalize(vNormal);
  float incidentAngle = acos(dot(-viewDirection, N));
  float ct[number_layer],d[number_layer];
  vec2 ior[number_layer],t_listp[number_layer-1],t_lists[number_layer-1],r_listp[number_layer-1], r_lists[number_layer-1],delta[number_layer];

  vec3 R = vec3(0.f);
  vec3 reflectDirection = reflect(viewDirection,N);
  //vec3 reflectDirectionWorld = reflectDirection;
  mat4 Ms[number_layer],Mp[number_layer];
  mat4 A,Bp,Bs;

  Ms[0] = mat4(1.f);
  Mp[0] = mat4(1.f);
  
  ior[0] = vec2(1.f,0.f); //air
  ior[1] = vec2(layer1.x,layer1.y);
  ior[2] = vec2(layer2.x,layer2.y);
  ior[3] = vec2(layer3.x,layer3.y);
  ior[4] = vec2(layer4.x,layer4.y);
  ior[5] = vec2(layer5.x,layer5.y);
  ior[6] = vec2(1.49f,0.f); //polypropylène

  d[0] = 1000000.f;
  d[1] = layer1.z;
  d[2] = layer2.z;
  d[3] = layer3.z;
  d[4] = layer4.z;
  d[5] = layer5.z;
  d[6] = 1000000.f;

  ct[0] = dot(-viewDirection, N);

  float ctsqr = (1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[1].x)*(ior[0].x/ior[1].x));

  if (ctsqr<0.f)
      R = vec3(1.f);
  else{
    for(int i=0;i<number_layer-1;++i)
    {
      ct[i+1] = sqrt(1.f-(1.f-ct[0]*ct[0]) * (ior[0].x/ior[i+1].x)*(ior[0].x/ior[i+1].x));
      t_listp[i] = interface_t(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_listp[i] = interface_r(1, ior[i], ior[i+1],ct[i], ct[i+1]);
      t_lists[i] = interface_t(0, ior[i], ior[i+1],ct[i], ct[i+1]);
      r_lists[i] = interface_r(0, ior[i], ior[i+1],ct[i], ct[i+1]);
    }

    for(int wavelength = 0;wavelength<3;++wavelength)
    {
        for(int i=1;i<number_layer-1;++i)
        {
            delta[i] = (TWO_M_PI* ior[i] * ct[i]*d[i] / wavelengths[wavelength]);
        }
        for(int i=1;i<number_layer-1;++i)
        {
          A = A_m(delta[i]);
          Bp = Bp_m(r_listp[i]);
          Bs = Bs_m(r_lists[i]);

          Ms[i] = complex_time_matrix(t_lists[i],Ms[i-1])*A*Bs;
          Mp[i] = complex_time_matrix(t_listp[i],Mp[i-1])*A*Bp;
        }

        Bp = Bp_m(r_listp[0]);
        Bs = Bs_m(r_lists[0]);

        Ms[number_layer-1] = complex_time_matrix(t_lists[0],Bs)*Ms[number_layer-2];
        Mp[number_layer-1] = complex_time_matrix(t_listp[0],Bp)*Mp[number_layer-2];

        vec2 rs = retreive_r(Ms[number_layer-1]);
        vec2 rp = retreive_r(Mp[number_layer-1]);

        R[wavelength] = saturate(0.5f*(length(rs)*length(rs)+length(rp)*length(rp)));
    }
  }

  mat3 cameraCoordinateMatrix = mat3(viewMatrix);
  vec3 reflectDirectionWorld = vec3(
  -dot(cameraCoordinateMatrix[0],reflectDirection),
  dot(cameraCoordinateMatrix[1],reflectDirection),
  dot(cameraCoordinateMatrix[2],reflectDirection)
  );
  
  vec3 vColor = texture(tEnv,reflectDirectionWorld).rgb*R*ct[0]*exposure;
  fragColor = vec4(vColor, 1.f );
}`;
        }
    )
}

function _height(width) {
    return (
        Math.min(500, width)
    )
}

function _dataTextures(THREE, Coat_1_layer, Coat_4_layer, Iridescence_layer1, Iridescence_layer2) {
    return [
        new THREE.DataTexture(new Float32Array([1, 1, 1]), 1, 1, THREE.RGBFormat, THREE.FloatType), // Perfect Mirror
        new THREE.DataTexture(new Float32Array(Coat_1_layer), 91, 1, THREE.RGBFormat, THREE.FloatType), // 1 Layer anti-reflection coating        
        new THREE.DataTexture(new Float32Array(Coat_1_layer.slice(0, 3)), 1, 1, THREE.RGBFormat, THREE.FloatType), // Fake 1 Layer coating                            
        new THREE.DataTexture(new Float32Array(Coat_4_layer), 91, 1, THREE.RGBFormat, THREE.FloatType), // 4 Layer anti-reflection coating                            
        new THREE.DataTexture(new Float32Array(Coat_4_layer.slice(0, 3)), 1, 1, THREE.RGBFormat, THREE.FloatType), // Fake 4 Layer caoting                             
        new THREE.DataTexture(new Float32Array(Iridescence_layer1), 91, 1, THREE.RGBFormat, THREE.FloatType), // Iridescence Layer 1
        new THREE.DataTexture(new Float32Array(Iridescence_layer2), 91, 1, THREE.RGBFormat, THREE.FloatType), // Iridescence Layer 1
    ];
}


function _Coat_1_layer() {
    const rawData = {
        "R": [0.017828628328346703, 0.01782620077280887, 0.017818936600813857, 0.017806891364654978, 0.017790157880441405, 0.017768866574442883, 0.01774318597385883, 0.01771332334803968, 0.017679525508107852, 0.01764207977500221, 0.017601315128231675, 0.017557603550112252, 0.01751136158301582, 0.017463052120219095, 0.01741318645435059, 0.017362326611239005, 0.017311088001216317, 0.017260142424675433, 0.017210221473981466, 0.017162120379747976, 0.017116702356079087, 0.01707490350671533, 0.017037738362182964, 0.0170063061271146, 0.016981797726974765, 0.016965503754588995, 0.01695882342924517, 0.01696327469483842, 0.01698050559869535, 0.017012307109494633, 0.017060627551266055, 0.017127588850986915, 0.01721550482001894, 0.01732690171477705, 0.017464541349870157, 0.01763144706780535, 0.0178309329035584, 0.01806663632027541, 0.018342554934543707, 0.018663087696567625, 0.01903308104279863, 0.019457880596776098, 0.019943389058901542, 0.02049613099848463, 0.02112332534266564, 0.021832966447900268, 0.022633914741908016, 0.02353599803885992, 0.024550124759855935, 0.025688410436428378, 0.026964319039207235, 0.028392820859663, 0.029990568883073932, 0.03177609582909496, 0.03377003430666602, 0.03599536283726243, 0.03847768085024448, 0.04124551615280763, 0.04433066883240702, 0.04776859607046463, 0.051598842943233296, 0.055865524971331244, 0.060617868968456584, 0.06591081964969561, 0.07180572051159699, 0.07837107871485038, 0.08568342511606428, 0.09382828224397419, 0.10290125494120514, 0.11300926064840902, 0.12427191895767327, 0.13682312318508888, 0.1508128204044162, 0.16640903076288388, 0.18380014211166862, 0.20319752220708479, 0.2248384981968268, 0.24898976207591242, 0.27595127162577937, 0.30606072947165563, 0.3396987388548147, 0.3772947542092458, 0.4193339685343507, 0.46636530898642403, 0.5190107485058358, 0.5779761865005835, 0.6440642080086499, 0.7181891014673841, 0.8013946042891429, 0.8948749582193181, 0.9999999999999992],
        "G": [0.019672141087613067, 0.01966902529787666, 0.01965969691764215, 0.01964421298750323, 0.019622668821374492, 0.019595198378323554, 0.01956197478808573, 0.019523211035356564, 0.019479160809619138, 0.01943011952908629, 0.019376425549354658, 0.019318461569620846, 0.01925665625184118, 0.019191486071068017, 0.01912347741841417, 0.01905320898173309, 0.01898131443320656, 0.018908485457661932, 0.01883547516065534, 0.018763101901222913, 0.01869225360078611, 0.018623892587075697, 0.018559061040193482, 0.01849888711714834, 0.018444591841479722, 0.018397496856022395, 0.01835903314958348, 0.01833075088242494, 0.01831433045110692, 0.018311594950605796, 0.018324524210844507, 0.018355270606051455, 0.01840617685891359, 0.018479796087544284, 0.018578914372124652, 0.018706576149994804, 0.01886611278332658, 0.01906117468268726, 0.019295767413261198, 0.01957429225874363, 0.019901591771546108, 0.020283000897628783, 0.02072440433076817, 0.021232300825266164, 0.02181387527901175, 0.02247707949158703, 0.023230722606090975, 0.02408457236006652, 0.025049468402118198, 0.026137449078516197, 0.027361893260622043, 0.02873767897202537, 0.030281360786937866, 0.032011368212222134, 0.03394822753858289, 0.03611480995670953, 0.038536609087119485, 0.041242051474612726, 0.0442628440572289, 0.04763436314429103, 0.051396090039038556, 0.05559209913082552, 0.0602716050745394, 0.06548957658811956, 0.07130742545350517, 0.07779378052670867, 0.08502535797860324, 0.09308794063503296, 0.10207748120600235, 0.11210134644098912, 0.12327972188412445, 0.13574720000617768, 0.14965457815430686, 0.16517089710117827, 0.18248575613500723, 0.20181194678763983, 0.22338845466792476, 0.24748388772475188, 0.27440039994910337, 0.3044781924648384, 0.3381006896925303, 0.3757005074813509, 0.417766353656854, 0.4648510304334408, 0.5175807440065682, 0.5766659711977846, 0.6429141886397036, 0.7172448397346605, 0.8007070025256703, 0.8945003329785013, 0.9999999999999996],
        "B": [0.02988908924498443, 0.029884538547260392, 0.029870902213775426, 0.029848227653905084, 0.02981659431787164, 0.02977611434940246, 0.029726933501027723, 0.029669232313706134, 0.029603227563111408, 0.02952917397568673, 0.02944736621850838, 0.02935814116813236, 0.02926188046497253, 0.029159013361418833, 0.029050019873901604, 0.028935434251502315, 0.028815848776562496, 0.028691917916124916, 0.02856436284703131, 0.02843397638218606, 0.02830162833097074, 0.028168271333165386, 0.028034947213112043, 0.0279027939093712, 0.027773053044906314, 0.027647078214032294, 0.027526344075140815, 0.027412456352738063, 0.027307162868783343, 0.027212365741899187, 0.027130134913946335, 0.027062723186950792, 0.02701258297968236, 0.026982385042580773, 0.02697503940249986, 0.026993718845204198, 0.027041885284059545, 0.027123319408286668, 0.02724215405392439, 0.02740291179575339, 0.02761054731939553, 0.027870495200242006, 0.028188723790461882, 0.028571795997903424, 0.02902693783212979, 0.029562115694188738, 0.030186123499216976, 0.03090868084604059, 0.03174054358718574, 0.032693628308065846, 0.03378115239775586, 0.03501779158826908, 0.03641985705757626, 0.03800549443718633, 0.039794907341941625, 0.04181060835238234, 0.04407770073398644, 0.046624194579022726, 0.04948136151294431, 0.05268413262664853, 0.056271544888459216, 0.06028724196694031, 0.06478003617129632, 0.06980453910627589, 0.07542186966229533, 0.08170044914171579, 0.0887168946860886, 0.09655702374947414, 0.10531698419922046, 0.11510452676584054, 0.12604043906642654, 0.1382601633630949, 0.15191562367756345, 0.16717729197426784, 0.1842365279830054, 0.2033082330269522, 0.22463386516483508, 0.24848487131316482, 0.2751666021219786, 0.3050227876614125, 0.3384406669787601, 0.3758568829989689, 0.4177642769537504, 0.46471974467938226, 0.5173533521991118, 0.5763789519227931, 0.6426065960578344, 0.7169571137124735, 0.8004793070051479, 0.894370334991837, 0.9999999999999991]
    };
    const data = [];
    [...Array(91).keys()].forEach((i) => {
        data.push(rawData.R[i]);
        data.push(rawData.G[i]);
        data.push(rawData.B[i]);
    });
    return data;
}


function _Coat_4_layer() {
    const rawData = {
        R: [0.0014700989531489688, 0.0014714687812553613, 0.001475585129289977, 0.0014824686132538316, 0.001492153678996269, 0.001504688741469995, 0.0015201364006211466, 0.001538573754765263, 0.0015600928381345161, 0.0015848012150149865, 0.0016128227684946129, 0.001644298727275993, 0.0016793889792373641, 0.001718273725406969, 0.0017611555327119483, 0.0018082618482318192, 0.0018598480416971018, 0.0019162010465975311, 0.001977643673492387, 0.002044539671950823, 0.0021172996200221196, 0.002196387722299866, 0.0022823295995919916, 0.002375721155065912, 0.0024772386036827675, 0.0025876497539841716, 0.0027078266341275113, 0.00283875955781174, 0.002981572730783227, 0.003137541505410742, 0.0033081113998757847, 0.0034949190104024185, 0.0036998149602676784, 0.003924889048750692, 0.004172497787404929, 0.004445294540807054, 0.004746262525014176, 0.005078750960120489, 0.005446514724324869, 0.0058537579165721535, 0.006305181803865754, 0.006806037708496637, 0.007362185480387235, 0.007980158301175856, 0.008667234680198364, 0.009431518628775809, 0.010282029138799068, 0.011228800245143819, 0.012282993119644444, 0.013457021827985614, 0.014764694580876472, 0.01622137252841761, 0.017844148383088804, 0.019652047414095347, 0.021666253636162147, 0.02391036432204397, 0.02641067630343262, 0.02919650789366201, 0.03230056067251082, 0.03575932582412534, 0.03961354022019827, 0.04390869799949028, 0.04869562401995843, 0.05403111626053929, 0.059978665036359784, 0.06660925777516417, 0.07400227909647161, 0.08224651705187586, 0.09144128763969878, 0.10169769111587726, 0.1131400152030696, 0.12590730207083994, 0.14015509794297804, 0.15605740640778804, 0.17380886899129344, 0.19362719933377504, 0.2157559004246583, 0.2404672978442467, 0.2680659258874006, 0.29889230786993976, 0.33332717692470293, 0.3717961892820699, 0.4147751885256006, 0.4627960867766014, 0.5164534373919549, 0.5764117838110637, 0.6434138809805114, 0.7182898997240628, 0.8019677410228339, 0.8954846070720246, 0.9999999999999994],

        G: [0.0010399550534184003, 0.0010413933326861246, 0.001045722800425235, 0.0010529873000422567, 0.0010632597519170308, 0.0010766419349596801, 0.001093264199910408, 0.0011132851337586425, 0.001136891200545393, 0.0011642963899364213, 0.0011957419113379593, 0.00123149597797878, 0.0012718537322945448, 0.0013171373710925286, 0.0013676965363046503, 0.0014239090445885582, 0.0014861820365343588, 0.0015549536336870791, 0.0016306951989043662, 0.0017139143026343184, 0.001805158504423116, 0.0019050200652593902, 0.0020141417121681505, 0.0021332235817421072, 0.0022630314740452904, 0.0024044065525903654, 0.002558276629983806, 0.002725669182523597, 0.002907726240767459, 0.0031057213071930536, 0.00332107845695427, 0.003555393783900458, 0.0038104593620572995, 0.004088289903343916, 0.00439115230618625, 0.004721598307719846, 0.005082500475372153, 0.005477091802751287, 0.005909009210973958, 0.006382341300910581, 0.006901680755407271, 0.007472181854479297, 0.00809962364187247, 0.008790479369371315, 0.009551992946886734, 0.01039226324274985, 0.011320337210819008, 0.012346312969982612, 0.013481454128421836, 0.014738316830573467, 0.016130891210125512, 0.017674759158669257, 0.01938727056799101, 0.021287740475762096, 0.02339766984114445, 0.025740993000460354, 0.02834435520588172, 0.031237424034885497, 0.034453238878477066, 0.03802860317608809, 0.04200452456975408, 0.04642670870579285, 0.05134611302604643, 0.05681956757147026, 0.06291047057854818, 0.06968956749547038, 0.07723582299389366, 0.0856373966191778, 0.09499273392556684, 0.10541178630397123, 0.11701737425349726, 0.12994671060249582, 0.14435310218477418, 0.16040785076229075, 0.17830237660596268, 0.19825059116021962, 0.22049154869698162, 0.2452924108995727, 0.27295176301676305, 0.3038033257281511, 0.3382201133345951, 0.3766190965439273, 0.41946643722795407, 0.4672833734139362, 0.5206528458566865, 0.5802269733343242, 0.6467355029678146, 0.7209953851872671, 0.8039216514599524, 0.8965398078049617, 0.9999999999999993],

        B: [0.0014560357477982648, 0.001454781111846814, 0.0014510228114415803, 0.0014447777923176342, 0.0014360747111481554, 0.0014249545648092163, 0.0014114715881113713, 0.0013956944357887465, 0.0013777076677128702, 0.0013576135585616114, 0.0013355342544190745, 0.0013116142989582909, 0.0012860235509833263, 0.0012589605132660151, 0.0012306560899706615, 0.001201377786762837, 0.0011714343642722901, 0.0011411809523310563, 0.0011110246298166768, 0.001081430473538621, 0.0010529280800085424, 0.001026118566755788, 0.0010016820657198409, 0.0009803857307859474, 0.0009630922952897658, 0.0009507692337785533, 0.0009444986058389055, 0.0009454876885836039, 0.0009550805384503354, 0.0009747706621001041, 0.001006215019984486, 0.0010512496339049465, 0.0011119071207153454, 0.0011904365271108355, 0.0012893258939359437, 0.0014113280312642337, 0.001559490036273949, 0.0017371871333754698, 0.0019481614590506399, 0.0021965664516760256, 0.002487017538909335, 0.0028246498422713063, 0.0032151836412712687, 0.0036649983594620192, 0.004181215854611105, 0.0047717938179758414, 0.005445630117458629, 0.006212678960875569, 0.007084079813945607, 0.008072300088599585, 0.009191292726810515, 0.010456669949500839, 0.011885894625349995, 0.01349849094657843, 0.015316276383974335, 0.017363617237367585, 0.01966771050624164, 0.02225889528411297, 0.025170997436020054, 0.028441711957969462, 0.03211302814870459, 0.03623170355755038, 0.04084979361953815, 0.04602524496563608, 0.05182256162058779, 0.0583135546970404, 0.06557818779131834, 0.07370553211891612, 0.08279484753989015, 0.09295680806817434, 0.10431489329739702, 0.11700697048420428, 0.13118709589777441, 0.14702756857688398, 0.16472127495826427, 0.184484369098466, 0.2065593405776353, 0.23121853084755212, 0.25876816900098615, 0.2895530099646592, 0.3239616722653205, 0.36243278914517174, 0.40546210631669705, 0.45361068250948355, 0.5075143756891303, 0.5678948289918877, 0.6355722066374614, 0.7114799720118545, 0.7966820484211637, 0.8923927583520155, 0.9999999999999994]
    };
    const data = [];
    [...Array(91).keys()].forEach((i) => {
        data.push(rawData.R[i]);
        data.push(rawData.G[i]);
        data.push(rawData.B[i]);
    });
    return data;
}


function _Iridescence_layer1() {
    const rawData = {
        R: [0.15768235660819999, 0.1577457922414247, 0.15793597795142533, 0.15825254931008115, 0.1586948960953129, 0.15926215810433175, 0.1599532194434613, 0.16076670144386956, 0.16170095439254223, 0.1627540483059936, 0.16392376301032346, 0.165207577825145, 0.16660266118058115, 0.1681058605260037, 0.16971369291655536, 0.1714223366889298, 0.17322762466151087, 0.17512503931598936, 0.17710971043799695, 0.1791764157131443, 0.18131958479190008, 0.18353330735162837, 0.18581134569617475, 0.18814715244179414, 0.190533893841749, 0.19296447929916505, 0.19543159760697162, 0.1979277604330683, 0.20044535353609502, 0.202976696150119, 0.20551410891288502, 0.2080499906297956, 0.2105769040623914, 0.2130876708040455, 0.21557547515544928, 0.21803397673751035, 0.2204574313794722, 0.22284081959635765, 0.22517998172450282, 0.22747175852066814, 0.2297141357546797, 0.23190639104552707, 0.2340492409167679, 0.23614498579211335, 0.238197650432548, 0.24021311715154575, 0.2421992490571147, 0.24416600058299334, 0.24612551271209288, 0.24809219058881674, 0.2500827616866517, 0.2521163133623146, 0.2542143094994472, 0.2564005870250391, 0.25870133435950865, 0.2611450553114274, 0.26376252350969714, 0.2665867341247397, 0.26965286129924376, 0.2729982313145002, 0.27666232298602256, 0.2806868080452904, 0.28511564527291267, 0.28999524287752126, 0.2953747040728797, 0.30130617104064883, 0.30784528256789123, 0.31505176074890295, 0.3229901424123135, 0.33173067158377184, 0.34135037055958384, 0.3519343093116835, 0.36357709626019974, 0.376384618259222, 0.39047606431147136, 0.4059862764928847, 0.42306848336500513, 0.44189748646917915, 0.4626733902390922, 0.4856259910564199, 0.51101997386533, 0.53916110702182, 0.5704036809971381, 0.6051595084760285, 0.6439088982421188, 0.6872141413211137, 0.7357362168040646, 0.7902556530868292, 0.851698791506119, 0.9211711275767841],
        G: [0.08402301712167339, 0.08408726054081442, 0.08428008012779317, 0.08460174131784609, 0.08505267802093519, 0.08563348000106108, 0.08634487541136338, 0.08718770868705275, 0.08816291405303134, 0.08927148495564255, 0.09051443977783839, 0.09189278424371428, 0.09340747096143852, 0.09505935659284023, 0.09684915717327072, 0.09877740213692926, 0.10084438763109656, 0.10305012972834755, 0.10539431816976988, 0.10787627129571395, 0.11049489284499966, 0.11324863133013871, 0.11613544272625836, 0.1191527572459319, 0.12229745101140602, 0.12556582347943454, 0.12895358152081482, 0.13245583110452416, 0.1360670775816486, 0.139781235602642, 0.14359164972738753, 0.14749112679486953, 0.1514719811013338, 0.15552609338591555, 0.15964498453453424, 0.1638199047808796, 0.16804193900346914, 0.17230212848753995, 0.1765916092396997, 0.18090176661373708, 0.18522440563228013, 0.1895519359780989, 0.1938775701902792, 0.1981955331462098, 0.20250128045465476, 0.20679172294474946, 0.21106545402949373, 0.2153229763713913, 0.21956692400578348, 0.22380227590976082, 0.2280365569687604, 0.23228002241783138, 0.23654582214890726, 0.24085014180673342, 0.24521231836808244, 0.24965492892887362, 0.2542038527194603, 0.25888830792453177, 0.26374086667993907, 0.2687974536159189, 0.27409733545837894, 0.27968311141480434, 0.28560071627507494, 0.2918994502616258, 0.2986320515847575, 0.3058548293310103, 0.31362787569793776, 0.32201537769108396, 0.33108604927373836, 0.34091370572140056, 0.35157800275861156, 0.36316536418793677, 0.37577012346467364, 0.38949590739255324, 0.40445729424295274, 0.4207817846264768, 0.4386121319441872, 0.4581090908935551, 0.4794546581237812, 0.5028558997551307, 0.5285494874189138, 0.5568070994740053, 0.5879418894268553, 0.6223162824471926, 0.6603514374772141, 0.7025388125923661, 0.7494544029968762, 0.8017763954339328, 0.8603072153615108, 0.9260012557841566],
        B: [0.2013471886246142, 0.20128502236155563, 0.2010983238465568, 0.20078649708427113, 0.20034855936477353, 0.19978315721587103, 0.19908858878978425, 0.19826283272774142, 0.19730358354412095, 0.19620829355879132, 0.1949742213794886, 0.19359848689255374, 0.19207813265722606, 0.1904101915131038, 0.1885917600996525, 0.18662007784856097, 0.1844926108427955, 0.18220713973993946, 0.17976185073300444, 0.1771554282725717, 0.17438714800580868, 0.17145696810991906, 0.1683656169231026, 0.16511467452282869, 0.16170664569155252, 0.1581450215709636, 0.15443432726868514, 0.15058015278007436, 0.14658916485746054, 0.14246909793282042, 0.13822872290489116, 0.13387779355516155, 0.12942697156097088, 0.12488773250976232, 0.1202722569435001, 0.11559331220599407, 0.11086413262981026, 0.10609830725921252, 0.10130968571669664, 0.09651231382806572, 0.0917204110712932, 0.08694840167055064, 0.0822110101128424, 0.07752342995950393, 0.07290157205208109, 0.06836239462604506, 0.06392431356114772, 0.05960768618436353, 0.055435356917555245, 0.05143324788076198, 0.047630972603221584, 0.04406244655641052, 0.04076646461916325, 0.03778721313905081, 0.03517468330098812, 0.03298495339090174, 0.03128031057354087, 0.030129188270627626, 0.029605903320907814, 0.029790187869111875, 0.030766524187553518, 0.03262330591592013, 0.03545186571285605, 0.039345425911527857, 0.044398044044073146, 0.0507036374763095, 0.058355179344713376, 0.06744416026532982, 0.0780604061740636, 0.0902923321837486, 0.10422769637932713, 0.11995489771766961, 0.1375648410046239, 0.1571533719920586, 0.17882426965050152, 0.202692772904577, 0.22888961713740508, 0.2575655622634572, 0.28889640892484614, 0.3230885213997723, 0.36038490359901293, 0.4010719062751805, 0.4454866774757469, 0.4940255027031441, 0.5471532148293761, 0.6054138854074855, 0.66944303759613, 0.7399816453489133, 0.817892202380663, 0.9041771557423928]
    };
    const data = [];
    [...Array(91).keys()].forEach((i) => {
        data.push(rawData.R[i]);
        data.push(rawData.G[i]);
        data.push(rawData.B[i]);
    });
    return data;
}


function _Iridescence_layer2() {
    const rawData = {
        R: [0.02895933001229866, 0.02897209323240605, 0.02901037938257211, 0.029074177775835416, 0.029163470086787536, 0.029278229608226243, 0.029418420264914123, 0.029583995438237295, 0.02977489666999684, 0.029991052327297003, 0.030232376323363362, 0.030498767000969713, 0.030790106295816203, 0.03110625930654122, 0.03144707440592166, 0.031812384034106994, 0.03220200631933162, 0.03261574767440603, 0.03305340651833291, 0.03351477827165915, 0.033999661771671665, 0.034507867249382006, 0.03503922600453545, 0.03559360190782025, 0.0361709048512572, 0.03677110625869606, 0.03739425675875244, 0.03804050611273111, 0.0387101254805105, 0.03940353209842093, 0.04012131643532078, 0.04086427188685015, 0.04163342706378613, 0.042430080729112474, 0.04325583944052605, 0.04411265796133418, 0.04500288251385779, 0.04592929696643316, 0.046895172068878645, 0.04790431788295096, 0.04896113959505059, 0.05007069694952255, 0.05123876760370863, 0.05247191478184435, 0.053777559695396646, 0.05516405930390065, 0.05664079011410455, 0.05821823885744571, 0.059908101047555944, 0.06172338860138545, 0.0636785479101167, 0.06578958996952045, 0.06807423442371795, 0.0705520696412061, 0.07324473122710791, 0.07617610168065889, 0.07937253423190711, 0.0828631042370579, 0.08667989187924313, 0.09085830031345278, 0.09543741381532213, 0.10046040095001148, 0.10597496827887035, 0.11203387068059811, 0.1186954849968842, 0.12602445444153132, 0.1340924120641168, 0.1429787925685606, 0.15277174299617613, 0.16356914424484686, 0.17547975717655173, 0.18862450924605217, 0.2031379402655221, 0.21916982922957517, 0.23688702822044766, 0.25647553449188504, 0.2781428381409198, 0.30212059063160845, 0.3286676492272237, 0.35807356461338313, 0.39066259428021133, 0.4267983433685834, 0.4668891586764195, 0.5113944316392353, 0.5608320039658105, 0.6157869172975716, 0.6769218084288265, 0.7449893277060646, 0.8208470546673007, 0.9054755075901395],

        G: [0.019376402870301523, 0.019388017049273114, 0.019422899659523644, 0.01948117048310096, 0.01956302770442976, 0.01966874575826884, 0.019798672369824896, 0.01995322484020849, 0.02013288564586195, 0.020338197436136067, 0.02056975752878109, 0.020828212018629586, 0.021114249630034637, 0.021428595458478854, 0.021772004760944184, 0.022145256967856942, 0.022549150101389054, 0.022984495795308334, 0.02345211512011845, 0.023952835423646134, 0.02448748840129073, 0.02505690961167932, 0.025661939652393117, 0.026303427206755044, 0.026982234166511715, 0.027699243026838093, 0.028455366739784736, 0.029251561200518778, 0.030088840528040586, 0.03096829528910089, 0.03189111380149757, 0.03285860664150338, 0.03387223447061215, 0.03493363928978896, 0.0360446792256697, 0.03720746695330136, 0.0384244118646258, 0.039698266101525694, 0.04103217458734664, 0.0424297292118716, 0.043895027352232434, 0.045432734946752054, 0.0470481543808554, 0.04874729749475574, 0.05053696408258229, 0.05242482632313839, 0.0544195196649865, 0.0565307407846941, 0.05876935334872065, 0.061147502438678086, 0.06367873864876832, 0.06637815303548067, 0.06926252429548921, 0.07235047977058646, 0.07566267213080864, 0.07922197387109456, 0.08305369207534972, 0.0871858062573756, 0.09164923248387624, 0.09647811742455131, 0.10171016646315102, 0.10738701054806604, 0.11355461707072265, 0.12026375074712768, 0.1275704912589677, 0.13553681530760847, 0.14423125177573012, 0.15372961991386633, 0.164115861919409, 0.17548298301230378, 0.18793411420775527, 0.20158371553229443, 0.21655894053711097, 0.23300118676877302, 0.25106786153058486, 0.2709343980142351, 0.29279656395413795, 0.3168731136668078, 0.34340884506694586, 0.37267813647173786, 0.40498905429675325, 0.44068814283078667, 0.48016603204585806, 0.5238640299627628, 0.5722819038345441, 0.6259871010553804, 0.6856257184040606, 0.7519355996788291, 0.8257620303258061, 0.9080766074727902],

        B: [0.03418667435389543, 0.03417369826255555, 0.03413474215605872, 0.03406972343710252, 0.03397850743829203, 0.03386091189428279, 0.033716713161929396, 0.033545654145741, 0.03334745387121103, 0.03312181863213565, 0.03286845461969817, 0.03258708192081956, 0.032277449751170834, 0.03193935276459731, 0.03157264825599341, 0.031177274049611597, 0.030753266840320502, 0.030300780732658013, 0.029820105703087692, 0.029311685696363544, 0.028776136059232234, 0.028214260015930793, 0.027627063902240796, 0.027015770900421007, 0.02638183305822562, 0.0257269414332435, 0.025053034280349096, 0.024362303295929835, 0.02365719804772007, 0.02294042885254132, 0.02221496851385612, 0.021484053493387553, 0.02075118526138843, 0.020020132742429322, 0.01929493694062547, 0.01857991898192415, 0.01787969294280059, 0.017199184935762963, 0.016543659984314736, 0.015918758236504574, 0.015330542031839166, 0.01478555524855612, 0.01429089621754547, 0.013854305299492373, 0.01348426799068829, 0.013190134161621094, 0.012982253755451562, 0.01287212899816413, 0.012872582917968363, 0.0129979437590544, 0.013264244724897453, 0.013689438419048523, 0.014293625385131261, 0.015099296298523406, 0.01613158764281777, 0.017418551124080597, 0.018991437641045956, 0.020884997342129515, 0.023137798159801246, 0.02579256621609758, 0.028896552634643767, 0.03250193256820406, 0.03666624365012166, 0.04145287259775763, 0.046931600333109016, 0.053179217740620066, 0.06028022606002398, 0.06832763792406657, 0.07742389721555157, 0.08768193826167268, 0.09922640744106469, 0.11219507309414212, 0.12674045275217202, 0.1430316901944181, 0.16125671877022046, 0.1816247518512062, 0.20436914627396455, 0.22975069025543954, 0.25806137356011083, 0.28962870469901325, 0.3248206476481852, 0.3640512589555324, 0.407787115083868, 0.4565546292880154, 0.5109483670671018, 0.5716404790479024, 0.6393913797996809, 0.7150618103497693, 0.799626430992699, 0.8941890996105297]

    };
    const data = [];
    [...Array(91).keys()].forEach((i) => {
        data.push(rawData.R[i]);
        data.push(rawData.G[i]);
        data.push(rawData.B[i]);
    });
    return data;
}


function _checkerData() {
    return (
        [1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
            0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1,
            1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
            0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1,
            1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
            0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1,
            1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
            0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1]
    )
}

function _checkerRGBData() {
    return (
        [1, 1, 1, 0.5, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 0.5]
    )
}

function _createCamera(THREE, width, height) {
    return (
        function createCamera() {
            const camera = new THREE.PerspectiveCamera(50, width / height, 1, 100000);
            camera.position.z = -4000;
            return camera;
        }
    )
}

function _29(createRenderer) {
    return (
        createRenderer()
    )
}

function _createRenderer(DOM, width, height, THREE) {
    return (
        function createRenderer() {
            const canvas = DOM.canvas(width, height);
            const context = canvas.getContext('webgl2');
            const renderer = new THREE.WebGLRenderer({canvas: canvas, context: context, antialias: true});
            renderer.getContext().getExtension('OES_texture_float'); // for float data texture
            renderer.getContext().getExtension('OES_texture_float_linear'); // for float data texture
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            return renderer;
        }
    )
}

function _createMaterial(coatingChoice, renderChoice, THREE, dataTextures, exposure, getVertexShader, getFragmentShader, ior1, getFragmentShader1layer, ior2, getFragmentShader2layers, ior3, getFragmentShader3layers, ior4, getFragmentShader4layers, ior5, getFragmentShader5layers) {
    return (
        function createMaterial(textureCube) {
            const choice = parseInt(coatingChoice);
            if (renderChoice == 0) {
                return new THREE.RawShaderMaterial({
                    uniforms: {
                        tEnv: {
                            value: textureCube
                        },
                        tData: {
                            value: dataTextures[choice]
                        },
                        tonemapFlag: {
                            value: choice
                        },
                        exposure: {
                            value: exposure
                        },
                    },
                    vertexShader: getVertexShader(),
                    fragmentShader: getFragmentShader(),
                });
                //return new THREE.MeshPhongMaterial( 
                //	{ color: 0xffffff, envMap: textureCube, refractionRatio: 0.98 }
                //);
            } else {
                if (coatingChoice == 1) {
                    return new THREE.RawShaderMaterial({
                        uniforms: {
                            tEnv: {
                                value: textureCube
                            },
                            tonemapFlag: {
                                value: choice
                            },
                            exposure: {
                                value: exposure
                            },
                            layer1: {
                                value: ior1
                            }
                        },
                        vertexShader: getVertexShader(),
                        fragmentShader: getFragmentShader1layer(),
                    });
                }
                if (coatingChoice == 2) {
                    return new THREE.RawShaderMaterial({
                        uniforms: {
                            tEnv: {
                                value: textureCube
                            },
                            tonemapFlag: {
                                value: choice
                            },
                            exposure: {
                                value: exposure
                            },
                            layer1: {
                                value: ior1
                            },
                            layer2: {
                                value: ior2
                            }
                        },
                        vertexShader: getVertexShader(),
                        fragmentShader: getFragmentShader2layers(),
                    });
                }
                if (coatingChoice == 3) {
                    return new THREE.RawShaderMaterial({
                        uniforms: {
                            tEnv: {
                                value: textureCube
                            },
                            tonemapFlag: {
                                value: choice
                            },
                            exposure: {
                                value: exposure
                            },
                            layer1: {
                                value: ior1
                            },
                            layer2: {
                                value: ior2
                            },
                            layer3: {
                                value: ior3
                            }
                        },
                        vertexShader: getVertexShader(),
                        fragmentShader: getFragmentShader3layers(),
                    });
                }
                if (coatingChoice == 4) {
                    return new THREE.RawShaderMaterial({
                        uniforms: {
                            tEnv: {
                                value: textureCube
                            },
                            tonemapFlag: {
                                value: choice
                            },
                            exposure: {
                                value: exposure
                            },
                            layer4: {
                                value: ior4
                            },
                            layer1: {
                                value: ior1
                            },
                            layer2: {
                                value: ior2
                            },
                            layer3: {
                                value: ior3
                            }
                        },
                        vertexShader: getVertexShader(),
                        fragmentShader: getFragmentShader4layers(),
                    });
                }
                if (coatingChoice == 5) {
                    return new THREE.RawShaderMaterial({
                        uniforms: {
                            tEnv: {
                                value: textureCube
                            },
                            tonemapFlag: {
                                value: choice
                            },
                            exposure: {
                                value: exposure
                            },
                            layer5: {
                                value: ior5
                            },
                            layer4: {
                                value: ior4
                            },
                            layer1: {
                                value: ior1
                            },
                            layer2: {
                                value: ior2
                            },
                            layer3: {
                                value: ior3
                            }
                        },
                        vertexShader: getVertexShader(),
                        fragmentShader: getFragmentShader5layers(),
                    });
                }
            }
        }
    )
}

function _loadTextureCube(THREE) {
    return (
        function loadTextureCube() {
            // const cubeTextureBase = "https://threejs.org/examples/textures/cube/Park3Med/";

            /* const urls = [
               cubeTextureBase + "px.jpg", cubeTextureBase + "nx.jpg",
               cubeTextureBase + "py.jpg", cubeTextureBase + "ny.jpg",
               cubeTextureBase + "pz.jpg", cubeTextureBase + "nz.jpg"
             ];*/
            /**/

            const cubeTextureBase = "https://threejs.org/examples/textures/cube/Bridge2/";
            var urls = [cubeTextureBase + 'posx.jpg', cubeTextureBase + 'negx.jpg',
                cubeTextureBase + 'posy.jpg', cubeTextureBase + 'negy.jpg',
                cubeTextureBase + 'posz.jpg', cubeTextureBase + 'negz.jpg'];

            const textureCube = new THREE.CubeTextureLoader().load(urls, function () {
                //textureCube.magFilter = THREE.LinearFilter;
                //textureCube.needsUpdate = true;
            });
            return textureCube;
        }
    )
}

function _loadHDRTexureCube(THREE) {
    return (
        function loadHDRTexureCube() {
            var hdrUrls = ['px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr'];
            const hdrCubeMap = new THREE.HDRCubeTextureLoader()
                .setPath('https://threejs.org/examples/textures/cube/pisaHDR/')
                .setDataType(THREE.UnsignedByteType)
                .load(hdrUrls, function () {

                    //hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );

                    hdrCubeMap.magFilter = THREE.LinearFilter;
                    hdrCubeMap.needsUpdate = true;
                });
            return hdrCubeMap;
        }
    )
}

function _loadRGBEtexture(THREE) {
    return (
        function loadRGBEtexture(renderer, scene) {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();
            new THREE.RGBELoader()
                .setDataType(THREE.UnsignedByteType)
                .setPath('https://threejs.org/examples/textures/equirectangular/')
                .load('royal_esplanade_1k.hdr', function (texture) {

                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;

                    scene.background = envMap;
                    texture.dispose();
                    pmremGenerator.dispose();
                });//return envMap;
        }
    )
}

function _addPointLight(THREE) {
    return (
        function addPointLight(scene) {
            const pointLight = new THREE.PointLight(0xffffff, 2);
            scene.add(pointLight);
            const sphere = new THREE.SphereBufferGeometry(100, 16, 8);
            const mesh = new THREE.Mesh(sphere,
                new THREE.MeshBasicMaterial({color: 0xffffff})
            );
            mesh.scale.set(0.05, 0.05, 0.05);
            pointLight.add(mesh);
            return pointLight;
        }
    )
}

function _loadModel(modelChoice, loadSphere, loadKnot, loadHelmet, loadBoomBox, loadLucy) {
    return (
        function (material, scene) {
            switch (modelChoice) {
                case "Sphere":
                    loadSphere(material, scene);
                    break;
                case "Knot":
                    loadKnot(material, scene);
                    break;
                case "Helmet":
                    loadHelmet(material, scene);
                    break;
                case "BoomBox":
                    loadBoomBox(material, scene);
                    break;
                case "Lucy":
                    loadLucy(material, scene);
                    break;
            }
        }
    )
}

function _loadHelmet(THREE, $0) {
    return (
        function loadHelmet(material, scene) {
            const loader = new THREE.GLTFLoader().setPath('https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/');
            const file = 'DamagedHelmet.gltf';
            loader.load(file, function (gltf) {
                let box = new THREE.Box3();
                $0.value = gltf.scene;
                gltf.scene.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = material;//new THREE.MeshNormalMaterial();//roughnessMipmapper.generateMipmaps( child.material);
                            child.scale.x = child.scale.y = child.scale.z = 1000;
                        }
                    }
                );
                if (scene) scene.add(gltf.scene);
            });
        }
    )
}

function _loadBoomBox(THREE, $0) {
    return (
        function loadBoomBox(material, scene) {
            const loader = new THREE.GLTFLoader().setPath('https://threejs.org/examples/models/gltf/BoomBox/glTF/');
            const file = 'BoomBox.gltf';
            loader.load(file, function (gltf) {
                let box = new THREE.Box3();
                $0.value = gltf.scene;
                gltf.scene.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = material;//new THREE.MeshNormalMaterial();//roughnessMipmapper.generateMipmaps( child.material);
                            child.scale.x = child.scale.y = child.scale.z = 120000;
                        }
                    }
                );
                if (scene) scene.add(gltf.scene);
            });
        }
    )
}

function _mesh() {
    return (
        0
    )
}

function _loadLucy(THREE) {
    return (
        function loadLucy(material, scene) {
            const loader = new THREE.PLYLoader();
            loader.load('https://threejs.org/examples/models/ply/binary/Lucy100k.ply', function (geometry) {
                geometry.computeVertexNormals();
                const s = 1.5;
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.x = mesh.scale.y = mesh.scale.z = s;
                if (scene) scene.add(mesh);
            });
        }
    )
}

function _loadSphere(THREE) {
    return (
        function loadSphere(material, scene) {
            const geometry = new THREE.SphereBufferGeometry(800.0, 48, 24);
            const mesh = new THREE.Mesh(geometry, material);
            if (scene) scene.add(mesh);
        }
    )
}

function _loadKnot(THREE) {
    return (
        function loadKnot(material, scene) {
            var geometry = new THREE.TorusKnotBufferGeometry(700, 200, 100, 16);
            geometry = geometry.toNonIndexed();
            const mesh = new THREE.Mesh(geometry, material);
            if (scene) scene.add(mesh);
        }
    )
}

function _loadCheckerTexture(THREE) {
    return (
        function loadCheckerTexture() {
            const width = 8;
            const height = 8;
            const size = width * height;
            const checker = [1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
                0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1,
                1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
                0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1,
                1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
                0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1,
                1, 0.5, 1, 0.5, 1, 0.5, 1, 0.5,
                0.5, 1, 0.5, 1, 0.5, 1, 0.5, 1];
            const data = new Float32Array(checker);

            // used the buffer to create a DataTexture

            return new THREE.DataTexture(data, width, height, THREE.LuminanceFormat, THREE.FloatType);
        }
    )
}

function _getVertexShader() {
    return (
        function getVertexShader() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 modelViewMatrix; // Supplied by ThreeJS
uniform mat4 projectionMatrix; // Supplied by ThreeJS
uniform mat3 normalMatrix;// Supplied by ThreeJS
//uniform mat4 modelMatrix;

in vec3 position;
in vec3 normal;
in vec2 uv;

out vec3 vNormal;
out vec3 vPosition;
out vec2 vUv;

void main()	{
  vUv = uv;
  vNormal = normalize(normalMatrix*normal);
  vPosition = (modelViewMatrix * vec4( position, 1.0 )).xyz;
  //vNormal = normalize(mat3(modelMatrix)*normal);
  //vPosition = (modelMatrix*vec4( position, 1.0 )).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
        }
    )
}

function _getFragmentShader() {
    return (
        function getFragmentShader() {
            return `#version 300 es
precision highp float;
precision mediump int;

uniform mat4 viewMatrix; // Supplied by ThreeJS
//uniform vec3 cameraPosition; // Supplied by ThreeJS

uniform samplerCube tEnv;
uniform sampler2D tData;
uniform int tonemapFlag;
uniform float exposure;

in vec3 vNormal;
in vec3 vPosition;
in vec2 vUv;

out vec4 fragColor;

#define saturate(a) clamp( a, 0.0, 1.0 )
#define one_over_pi_by_2 0.63661977236
vec3 tonemap(vec3 color){
  if (tonemapFlag == 0) return color;
  color *= exposure; 
  return saturate( color );
}
void main()	{
  vec3 viewDirection = normalize(vPosition);
  //vec3 viewDirection = normalize(vPosition-cameraPosition);
  vec3 N = normalize(vNormal);
  float incidentAngle = acos(dot(-viewDirection, N));
  float ct0 = dot(-viewDirection, N);
  vec3 reflectDirection = reflect(viewDirection,N);
  //vec3 reflectDirectionWorld = reflectDirection;
  
  mat3 cameraCoordinateMatrix = mat3(viewMatrix);
  vec3 reflectDirectionWorld = vec3(
  -dot(cameraCoordinateMatrix[0],reflectDirection),
  dot(cameraCoordinateMatrix[1],reflectDirection),
  dot(cameraCoordinateMatrix[2],reflectDirection)
  );
  vec3 vColor = texture(tEnv,reflectDirectionWorld).rgb*texture(tData, vec2(incidentAngle*one_over_pi_by_2,0.5)).rgb;
  fragColor = vec4( tonemap(vColor*ct0),1. );
}`;
        }
    )
}

async function _THREE(require) {
    const THREE = window.THREE = await require("three/build/three.min.js");
    await require("three/examples/js/controls/OrbitControls.js").catch(() => {
    });
    await require("three/examples/js/loaders/PLYLoader.js").catch(() => {
    });
    await require('three/examples/js/loaders/GLTFLoader.js').catch(() => {
    });
    await require('three/examples/js/loaders/RGBELoader.js').catch(() => {
    });
    await require('three/examples/js/loaders/HDRCubeTextureLoader.js').catch(() => {
    });
    return THREE;
}


export default function define(runtime, observer) {
    const main = runtime.module();
    main.variable(observer()).define(["md"], _1);
    main.variable(observer()).define(["md"], _2);
    main.variable(observer()).define(["md"], _3);
    main.variable(observer()).define(["md"], _4);
    main.variable(observer("viewof renderChoice")).define("viewof renderChoice", ["radio"], _renderChoice);
    main.variable(observer("renderChoice")).define("renderChoice", ["Generators", "viewof renderChoice"], (G, _) => G.input(_));
    main.variable(observer("viewof coatingChoice")).define("viewof coatingChoice", ["renderChoice", "radio"], _coatingChoice);
    main.variable(observer("coatingChoice")).define("coatingChoice", ["Generators", "viewof coatingChoice"], (G, _) => G.input(_));
    main.variable(observer("viewof modelChoice")).define("viewof modelChoice", ["radio"], _modelChoice);
    main.variable(observer("modelChoice")).define("modelChoice", ["Generators", "viewof modelChoice"], (G, _) => G.input(_));
    main.variable(observer("viewof exposure")).define("viewof exposure", ["slider"], _exposure);
    main.variable(observer("exposure")).define("exposure", ["Generators", "viewof exposure"], (G, _) => G.input(_));
    main.variable(observer("viewof ior1")).define("viewof ior1", ["coatingChoice", "renderChoice", "columns", "slider"], _ior1);
    main.variable(observer("ior1")).define("ior1", ["Generators", "viewof ior1"], (G, _) => G.input(_));
    main.variable(observer("viewof ior2")).define("viewof ior2", ["coatingChoice", "renderChoice", "columns", "slider"], _ior2);
    main.variable(observer("ior2")).define("ior2", ["Generators", "viewof ior2"], (G, _) => G.input(_));
    main.variable(observer("viewof ior3")).define("viewof ior3", ["coatingChoice", "renderChoice", "columns", "slider"], _ior3);
    main.variable(observer("ior3")).define("ior3", ["Generators", "viewof ior3"], (G, _) => G.input(_));
    main.variable(observer("viewof ior4")).define("viewof ior4", ["coatingChoice", "renderChoice", "columns", "slider"], _ior4);
    main.variable(observer("ior4")).define("ior4", ["Generators", "viewof ior4"], (G, _) => G.input(_));
    main.variable(observer("viewof ior5")).define("viewof ior5", ["coatingChoice", "renderChoice", "columns", "slider"], _ior5);
    main.variable(observer("ior5")).define("ior5", ["Generators", "viewof ior5"], (G, _) => G.input(_));
    main.variable(observer()).define(["createRenderer", "createCamera", "THREE", "loadTextureCube", "createMaterial", "loadModel"], _14);
    main.variable(observer("getFragmentShader1layer")).define("getFragmentShader1layer", _getFragmentShader1layer);
    main.variable(observer("getFragmentShader2layers")).define("getFragmentShader2layers", _getFragmentShader2layers);
    main.variable(observer("getFragmentShader3layers")).define("getFragmentShader3layers", _getFragmentShader3layers);
    main.variable(observer("getFragmentShader4layers")).define("getFragmentShader4layers", _getFragmentShader4layers);
    main.variable(observer("getFragmentShader5layers")).define("getFragmentShader5layers", _getFragmentShader5layers);
    main.variable(observer("height")).define("height", ["width"], _height);
    main.variable(observer("dataTextures")).define("dataTextures", ["THREE", "Coat_1_layer", "Coat_4_layer", "Iridescence_layer1", "Iridescence_layer2"], _dataTextures);
    main.variable(observer("Coat_1_layer")).define("Coat_1_layer", _Coat_1_layer);
    main.variable(observer("Coat_4_layer")).define("Coat_4_layer", _Coat_4_layer);
    main.variable(observer("Iridescence_layer1")).define("Iridescence_layer1", _Iridescence_layer1);
    main.variable(observer("Iridescence_layer2")).define("Iridescence_layer2", _Iridescence_layer2);
    main.variable(observer("checkerData")).define("checkerData", _checkerData);
    main.variable(observer("checkerRGBData")).define("checkerRGBData", _checkerRGBData);
    main.variable(observer("createCamera")).define("createCamera", ["THREE", "width", "height"], _createCamera);
    main.variable(observer()).define(["createRenderer"], _29);
    main.variable(observer("createRenderer")).define("createRenderer", ["DOM", "width", "height", "THREE"], _createRenderer);
    main.variable(observer("createMaterial")).define("createMaterial", ["coatingChoice", "renderChoice", "THREE", "dataTextures", "exposure", "getVertexShader", "getFragmentShader", "ior1", "getFragmentShader1layer", "ior2", "getFragmentShader2layers", "ior3", "getFragmentShader3layers", "ior4", "getFragmentShader4layers", "ior5", "getFragmentShader5layers"], _createMaterial);
    main.variable(observer("loadTextureCube")).define("loadTextureCube", ["THREE"], _loadTextureCube);
    main.variable(observer("loadHDRTexureCube")).define("loadHDRTexureCube", ["THREE"], _loadHDRTexureCube);
    main.variable(observer("loadRGBEtexture")).define("loadRGBEtexture", ["THREE"], _loadRGBEtexture);
    main.variable(observer("addPointLight")).define("addPointLight", ["THREE"], _addPointLight);
    main.variable(observer("loadModel")).define("loadModel", ["modelChoice", "loadSphere", "loadKnot", "loadHelmet", "loadBoomBox", "loadLucy"], _loadModel);
    main.variable(observer("loadHelmet")).define("loadHelmet", ["THREE", "mutable mesh"], _loadHelmet);
    main.variable(observer("loadBoomBox")).define("loadBoomBox", ["THREE", "mutable mesh"], _loadBoomBox);
    main.define("initial mesh", _mesh);
    main.variable(observer("mutable mesh")).define("mutable mesh", ["Mutable", "initial mesh"], (M, _) => new M(_));
    main.variable(observer("mesh")).define("mesh", ["mutable mesh"], _ => _.generator);
    main.variable(observer("loadLucy")).define("loadLucy", ["THREE"], _loadLucy);
    main.variable(observer("loadSphere")).define("loadSphere", ["THREE"], _loadSphere);
    main.variable(observer("loadKnot")).define("loadKnot", ["THREE"], _loadKnot);
    main.variable(observer("loadCheckerTexture")).define("loadCheckerTexture", ["THREE"], _loadCheckerTexture);
    main.variable(observer("getVertexShader")).define("getVertexShader", _getVertexShader);
    main.variable(observer("getFragmentShader")).define("getFragmentShader", _getFragmentShader);
    const child1 = runtime.module(define1);
    main.import("slider", child1);
    const child2 = runtime.module(define2);
    main.import("columns", child2);
    const child3 = runtime.module(define1);
    main.import("radio", child3);
    main.variable(observer("THREE")).define("THREE", ["require"], _THREE);
    return main;
}
